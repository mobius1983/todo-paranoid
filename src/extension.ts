import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';

interface CommentInfo {
  file: string;
  line: number;
  text: string;
  word: string;
  isBlocking: boolean; // Nueva propiedad para distinguir tipos
  category: 'blocking' | 'tracking';
}

async function checkFilesForForbiddenComments(
  resources: any[]
): Promise<CommentInfo[]> {
  const results: CommentInfo[] = [];
  const config = vscode.workspace.getConfiguration('todoParanoid');
  const blockingWords = config.get<string[]>('blockingWords', ['PARANOID']);

  for (const resource of resources) {
    const filePath = resource.fsPath || resource;
    if (fs.existsSync(filePath)) {
      const document = await vscode.workspace.openTextDocument(filePath);
      const comments = scanDocument(document);
      // Solo retornar comentarios que BLOQUEAN operaciones
      results.push(...comments.filter((c) => c.isBlocking));
    }
  }

  return results;
}

async function setupGitIntegration(): Promise<void> {
  try {
    // Esperar a que Git est√© disponible
    const gitExtension = vscode.extensions.getExtension('vscode.git');

    if (!gitExtension) {
      console.log(
        'üõ°Ô∏è Todo Paranoid: Git extension not found - using hooks only'
      );
      setupGitHooks();
      return;
    }

    if (!gitExtension.isActive) {
      console.log('üõ°Ô∏è Todo Paranoid: Waiting for Git extension to activate...');
      await gitExtension.activate();
    }

    const git = gitExtension.exports?.getAPI(1);
    if (!git) {
      console.log('üõ°Ô∏è Todo Paranoid: Git API not available - using hooks only');
      setupGitHooks();
      return;
    }

    console.log('üõ°Ô∏è Todo Paranoid: Git integration successful!');

    // Interceptar COMMITS (aqu√≠ s√≠ bloqueamos)
    git.repositories.forEach((repo: any) => {
      const originalCommit = repo.commit;
      repo.commit = async function (message: string, opts?: any) {
        const config = vscode.workspace.getConfiguration('todoParanoid');
        if (
          !config.get('enabled', true) ||
          !config.get('blockGitOperations', true)
        ) {
          return originalCommit.call(this, message, opts);
        }

        // Verificar archivos STAGED antes del commit
        const stagedFiles =
          repo.state.indexChanges?.map((change: any) => change.uri.fsPath) ||
          [];
        const blockingComments = await checkFilesForForbiddenComments(
          stagedFiles
        );

        if (blockingComments.length > 0) {
          const errorMessage = `üö´ Cannot commit! Found BLOCKING comments:\n${blockingComments
            .map(
              (f) => `üìÅ ${path.basename(f.file)} (Line ${f.line}): ${f.word}`
            )
            .join('\n')}\n\nüí° Remove these comments before committing!`;
          vscode.window.showErrorMessage(errorMessage);
          throw new Error('Blocking comments found - cannot commit');
        }

        return originalCommit.call(this, message, opts);
      };
    });

    // Setup Git hooks como respaldo
    setupGitHooks();
  } catch (error) {
    console.error('üõ°Ô∏è Todo Paranoid: Git integration failed:', error);
    // Fallback a solo Git hooks
    setupGitHooks();
  }
}

function setupGitHooks(): void {
  const workspaceFolders = vscode.workspace.workspaceFolders;
  if (!workspaceFolders) return;

  workspaceFolders.forEach((folder) => {
    const gitDir = path.join(folder.uri.fsPath, '.git');
    const hooksDir = path.join(gitDir, 'hooks');
    const preCommitHook = path.join(hooksDir, 'pre-commit');

    if (fs.existsSync(gitDir) && !fs.existsSync(preCommitHook)) {
      // Crear pre-commit hook autom√°ticamente
      const hookContent = generatePreCommitHook();

      vscode.window
        .showInformationMessage(
          'Todo Paranoid can create a Git pre-commit hook to block commits with forbidden comments. Create it?',
          'Yes',
          'No'
        )
        .then((selection) => {
          if (selection === 'Yes') {
            fs.mkdirSync(hooksDir, { recursive: true });
            fs.writeFileSync(preCommitHook, hookContent, { mode: 0o755 });
            vscode.window.showInformationMessage(
              'Git pre-commit hook created successfully!'
            );
          }
        });
    }
  });
}

function generatePreCommitHook(): string {
  const config = vscode.workspace.getConfiguration('todoParanoid');
  const blockingWords = config.get<string[]>('blockingWords', ['PARANOID']);

  return `#!/bin/sh
# Todo Paranoid pre-commit hook
# Auto-generated by Todo Paranoid VS Code Extension

# Only BLOCKING words prevent commits (git add is allowed)
BLOCKING_WORDS="${blockingWords.join('|')}"

# Check staged files for BLOCKING comments only
if git diff --cached --name-only | xargs grep -l -E "(//|#).*($BLOCKING_WORDS)" 2>/dev/null; then
    echo ""
    echo "üö´ Todo Paranoid: Cannot commit! BLOCKING comments found:"
    echo "================================================================"
    git diff --cached --name-only | xargs grep -n -E "(//|#).*($BLOCKING_WORDS)" 2>/dev/null | while read -r line; do
        echo "üìÅ $line"
    done
    echo "================================================================"
    echo ""
    echo "üí° You can save and test locally, but remove these comments before committing!"
    echo "üî• Blocking words: ${blockingWords.join(', ')}"
    echo ""
    echo "‚úÖ Note: TODO, FIXME, BUG comments are allowed and won't block commits."
    echo ""
    exit 1
fi

echo "‚úÖ Todo Paranoid: No blocking comments found - commit allowed!"
exit 0
`;
}

interface ForbiddenComment {
  file: string;
  line: number;
  text: string;
  word: string;
}

export function activate(context: vscode.ExtensionContext) {
  console.log('üõ°Ô∏è Todo Paranoid is now active!');

  // Inicializar decoraciones
  initializeDecorations();

  // Forzar que el contexto est√© disponible
  vscode.commands.executeCommand('setContext', 'todoParanoid.enabled', true);

  const provider = new CodeGuardianProvider();

  // Asignar a la variable global para que sea accesible en otras funciones
  globalProvider = provider;

  // Registrar provider primero
  vscode.window.registerTreeDataProvider('todoParanoidView', provider);

  const treeView = vscode.window.createTreeView('todoParanoidView', {
    treeDataProvider: provider,
    showCollapseAll: true,
  });

  console.log('üõ°Ô∏è Tree view created:', treeView.visible);

  // Comando para escanear workspace
  const scanCommand = vscode.commands.registerCommand(
    'todoParanoid.scanWorkspace',
    () => {
      provider.refresh();
      vscode.window.showInformationMessage('Todo Paranoid: Workspace scanned!');
    }
  );

  // Comando para refresh (interno) - REMOVIDO
  // const refreshCommand = vscode.commands.registerCommand('todoParanoid.refreshView', () => {
  //     provider.refresh();
  // });

  // Comando para toggle
  const toggleCommand = vscode.commands.registerCommand(
    'todoParanoid.toggleExtension',
    () => {
      const config = vscode.workspace.getConfiguration('todoParanoid');
      const currentState = config.get('enabled', true);
      config.update(
        'enabled',
        !currentState,
        vscode.ConfigurationTarget.Global
      );
      vscode.window.showInformationMessage(
        `Todo Paranoid ${!currentState ? 'enabled' : 'disabled'}`
      );
      provider.refresh(); // Refresh view after toggle
    }
  );

  // Comando para setup Git Hook
  const setupGitHookCommand = vscode.commands.registerCommand(
    'todoParanoid.setupGitHook',
    () => {
      setupGitHooksManual();
      vscode.window.showInformationMessage('Git Hook setup initiated!');
    }
  );

  // Comando para remover Git Hook
  const removeGitHookCommand = vscode.commands.registerCommand(
    'todoParanoid.removeGitHook',
    () => {
      removeGitHooks();
    }
  );

  function removeGitHooks(): void {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
      vscode.window.showErrorMessage('No workspace folder found!');
      return;
    }

    vscode.window
      .showWarningMessage(
        'Are you sure you want to remove Todo Paranoid git hooks?',
        'Yes, Remove',
        'Cancel'
      )
      .then((selection) => {
        if (selection !== 'Yes, Remove') return;

        let hooksRemoved = 0;

        workspaceFolders.forEach((folder) => {
          const gitDir = path.join(folder.uri.fsPath, '.git');
          const preCommitHook = path.join(gitDir, 'hooks', 'pre-commit');

          if (fs.existsSync(preCommitHook)) {
            try {
              // Verificar que sea nuestro hook leyendo el contenido
              const content = fs.readFileSync(preCommitHook, 'utf8');
              if (content.includes('Todo Paranoid pre-commit hook')) {
                fs.unlinkSync(preCommitHook);
                hooksRemoved++;
                console.log(`üóëÔ∏è Git hook removed from ${folder.name}`);
              } else {
                vscode.window.showWarningMessage(
                  `Pre-commit hook in ${folder.name} was not created by Todo Paranoid - skipping removal`
                );
              }
            } catch (error) {
              vscode.window.showErrorMessage(
                `Failed to remove git hook from ${folder.name}: ${error}`
              );
            }
          }
        });

        if (hooksRemoved > 0) {
          vscode.window.showInformationMessage(
            `üóëÔ∏è Git hooks removed from ${hooksRemoved} repository(ies)`
          );
        } else {
          vscode.window.showInformationMessage(
            'No Todo Paranoid git hooks found to remove'
          );
        }
      });
  }

  function setupGitHooksManual(): void {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
      vscode.window.showErrorMessage('No workspace folder found!');
      return;
    }

    let hooksCreated = 0;

    workspaceFolders.forEach((folder) => {
      const gitDir = path.join(folder.uri.fsPath, '.git');
      const hooksDir = path.join(gitDir, 'hooks');
      const preCommitHook = path.join(hooksDir, 'pre-commit');

      if (!fs.existsSync(gitDir)) {
        vscode.window.showWarningMessage(
          `No git repository found in ${folder.name}`
        );
        return;
      }

      if (fs.existsSync(preCommitHook)) {
        vscode.window.showWarningMessage(
          `Pre-commit hook already exists in ${folder.name}`
        );
        return;
      }

      try {
        // Crear directorio hooks si no existe
        fs.mkdirSync(hooksDir, { recursive: true });

        // Crear el hook
        const hookContent = generatePreCommitHook();
        fs.writeFileSync(preCommitHook, hookContent, { mode: 0o755 });

        hooksCreated++;
        console.log(`‚úÖ Git hook created in ${folder.name}`);
      } catch (error) {
        vscode.window.showErrorMessage(
          `Failed to create git hook in ${folder.name}: ${error}`
        );
      }
    });

    if (hooksCreated > 0) {
      vscode.window.showInformationMessage(
        `‚úÖ Git pre-commit hook created successfully in ${hooksCreated} repository(ies)!`
      );
    }
  }

  // Mostrar advertencia al guardar archivos con comentarios bloqueantes (pero permitir el guardado)
  const saveListener = vscode.workspace.onWillSaveTextDocument((event) => {
    const config = vscode.workspace.getConfiguration('todoParanoid');
    if (!config.get('enabled', true)) {
      return;
    }

    const document = event.document;
    const allComments = scanDocument(document);
    const blockingComments = allComments.filter((c) => c.isBlocking);

    if (blockingComments.length > 0 && config.get('showNotifications', true)) {
      // Solo mostrar advertencia, NO cancelar el guardado
      vscode.window
        .showWarningMessage(
          `File saved with ${blockingComments.length} BLOCKING comment(s). Remember: you won't be able to commit this!`,
          'Show Details'
        )
        .then((selection) => {
          if (selection === 'Show Details') {
            provider.refresh();
          }
        });
    }
  });

  // Interceptar comandos de Git usando la API de Git de VS Code (con manejo de errores)
  setupGitIntegration();

  // Escanear en tiempo real mientras escribes Y cuando guardas
  const changeListener = vscode.workspace.onDidChangeTextDocument((event) => {
    const config = vscode.workspace.getConfiguration('todoParanoid');
    if (!config.get('enabled', true)) return;

    const document = event.document;
    const allComments = scanDocument(document);

    if (allComments.length > 0 && config.get('showNotifications', true)) {
      // Decorar l√≠neas - diferentes colores para diferentes tipos
      highlightComments(document, allComments);
    }

    // Actualizar panel en tiempo real (con throttle para evitar spam)
    throttledRefresh();
  });

  // Listener para cuando se guarda un archivo
  const saveDocumentListener = vscode.workspace.onDidSaveTextDocument(
    (document) => {
      console.log('üõ°Ô∏è File saved, refreshing panel...');
      provider.refresh();
    }
  );

  // Listener para cuando se abre/cierra un archivo
  const openDocumentListener = vscode.workspace.onDidOpenTextDocument(
    (document) => {
      provider.refresh();
    }
  );

  // Listener para cuando se crea/elimina un archivo
  const fileSystemWatcher = vscode.workspace.createFileSystemWatcher(
    '**/*.{js,ts,jsx,tsx,py,java,cpp,c,cs,php,rb,go}'
  );

  fileSystemWatcher.onDidCreate(() => {
    console.log('üõ°Ô∏è File created, refreshing panel...');
    provider.refresh();
  });

  fileSystemWatcher.onDidDelete(() => {
    console.log('üõ°Ô∏è File deleted, refreshing panel...');
    provider.refresh();
  });

  fileSystemWatcher.onDidChange(() => {
    console.log('üõ°Ô∏è File changed, refreshing panel...');
    provider.refresh();
  });

  // Listener para cuando cambias de archivo activo
  const activeEditorListener = vscode.window.onDidChangeActiveTextEditor(
    (editor) => {
      if (editor) {
        const allComments = scanDocument(editor.document);
        if (allComments.length > 0) {
          highlightComments(editor.document, allComments);
        }
        // Actualizar panel cuando cambias de archivo
        provider.refresh();
      }
    }
  );

  context.subscriptions.push(
    scanCommand,
    toggleCommand,
    saveListener,
    changeListener,
    saveDocumentListener,
    openDocumentListener,
    fileSystemWatcher,
    activeEditorListener,
    treeView
  );

  // Escaneo inicial
  provider.refresh();

  // Log para debug
  console.log('üõ°Ô∏è Todo Paranoid: All components registered successfully');
}

function scanDocument(document: vscode.TextDocument): CommentInfo[] {
  const config = vscode.workspace.getConfiguration('todoParanoid');
  const blockingWords = config.get<string[]>('blockingWords', ['PARANOID']);
  const trackingWords = config.get<string[]>('trackingWords', [
    'TODO',
    'FIXME',
    'BUG',
  ]);
  const fileExtensions = config.get<string[]>('fileExtensions', ['.js', '.ts']);

  const fileExt = path.extname(document.fileName);
  if (!fileExtensions.includes(fileExt)) {
    return [];
  }

  const results: CommentInfo[] = [];
  const text = document.getText();
  const lines = text.split('\n');

  lines.forEach((line, index) => {
    // Verificar palabras bloqueantes (cr√≠ticas)
    blockingWords.forEach((word) => {
      const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
      if (commentRegex.test(line)) {
        results.push({
          file: document.fileName,
          line: index + 1,
          text: line.trim(),
          word: word,
          isBlocking: true,
          category: 'blocking',
        });
      }
    });

    // Verificar palabras de seguimiento (organizacionales)
    trackingWords.forEach((word) => {
      const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
      if (commentRegex.test(line)) {
        results.push({
          file: document.fileName,
          line: index + 1,
          text: line.trim(),
          word: word,
          isBlocking: false,
          category: 'tracking',
        });
      }
    });
  });

  return results;
}

// Mantener referencias globales a las decoraciones
let blockingDecorationType: vscode.TextEditorDecorationType;
let trackingDecorationType: vscode.TextEditorDecorationType;

// Variable global para el provider
let globalProvider: CodeGuardianProvider;

// Throttle function para evitar demasiadas actualizaciones
let refreshTimeout: NodeJS.Timeout | null = null;
function throttledRefresh() {
  if (refreshTimeout) {
    clearTimeout(refreshTimeout);
  }
  refreshTimeout = setTimeout(() => {
    // Usar el provider global
    if (globalProvider) {
      globalProvider.refresh();
    }
  }, 1000); // Actualizar despu√©s de 1 segundo de inactividad
}

function initializeDecorations() {
  // Decoraci√≥n para comentarios BLOQUEANTES (rojo)
  blockingDecorationType = vscode.window.createTextEditorDecorationType({
    backgroundColor: 'rgba(255, 0, 0, 0.3)',
    border: '2px solid red',
    borderRadius: '2px',
    overviewRulerColor: 'red',
    overviewRulerLane: vscode.OverviewRulerLane.Right,
  });

  // Decoraci√≥n para comentarios de SEGUIMIENTO (amarillo)
  trackingDecorationType = vscode.window.createTextEditorDecorationType({
    backgroundColor: 'rgba(255, 255, 0, 0.2)',
    border: '1px solid orange',
    borderRadius: '2px',
    overviewRulerColor: 'orange',
    overviewRulerLane: vscode.OverviewRulerLane.Right,
  });
}

function highlightComments(
  document: vscode.TextDocument,
  comments: CommentInfo[]
) {
  const editor = vscode.window.activeTextEditor;
  if (!editor || editor.document !== document) return;

  if (!blockingDecorationType || !trackingDecorationType) {
    initializeDecorations();
  }

  const blockingRanges = comments
    .filter((c) => c.isBlocking)
    .map((comment) => {
      const line = document.lineAt(comment.line - 1);
      return new vscode.Range(line.range.start, line.range.end);
    });

  const trackingRanges = comments
    .filter((c) => !c.isBlocking)
    .map((comment) => {
      const line = document.lineAt(comment.line - 1);
      return new vscode.Range(line.range.start, line.range.end);
    });

  editor.setDecorations(blockingDecorationType, blockingRanges);
  editor.setDecorations(trackingDecorationType, trackingRanges);
}

class CodeGuardianProvider implements vscode.TreeDataProvider<CommentInfo> {
  private _onDidChangeTreeData: vscode.EventEmitter<
    CommentInfo | undefined | null | void
  > = new vscode.EventEmitter<CommentInfo | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<
    CommentInfo | undefined | null | void
  > = this._onDidChangeTreeData.event;

  private allComments: CommentInfo[] = [];

  refresh(): void {
    this.scanWorkspace();
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: CommentInfo): vscode.TreeItem {
    // Headers de categor√≠a
    if (element.word === 'HEADER') {
      const item = new vscode.TreeItem(
        element.text,
        vscode.TreeItemCollapsibleState.None
      );
      item.iconPath = element.isBlocking
        ? new vscode.ThemeIcon(
            'error',
            new vscode.ThemeColor('errorForeground')
          )
        : new vscode.ThemeIcon('info', new vscode.ThemeColor('foreground'));
      item.contextValue = 'header';
      return item;
    }

    // Elementos normales de comentarios
    const item = new vscode.TreeItem(
      `${path.basename(element.file)} (Line ${element.line})`,
      vscode.TreeItemCollapsibleState.None
    );

    item.description = element.text;
    item.tooltip = `${element.file}:${element.line}\n${element.text}\nWord: ${element.word}\nType: ${element.category}`;

    // Diferentes iconos seg√∫n el tipo
    if (element.isBlocking) {
      item.iconPath = new vscode.ThemeIcon(
        'circle-filled',
        new vscode.ThemeColor('errorForeground')
      );
      item.contextValue = 'blockingComment';
    } else {
      item.iconPath = new vscode.ThemeIcon(
        'circle-outline',
        new vscode.ThemeColor('warningForeground')
      );
      item.contextValue = 'trackingComment';
    }

    item.command = {
      command: 'vscode.open',
      title: 'Open File',
      arguments: [
        vscode.Uri.file(element.file),
        {
          selection: new vscode.Range(element.line - 1, 0, element.line - 1, 0),
        },
      ],
    };

    return item;
  }

  getChildren(element?: CommentInfo): Thenable<CommentInfo[]> {
    if (!element) {
      // Organizar por categor√≠as y luego por archivos
      const blocking = this.allComments.filter((c) => c.isBlocking);
      const tracking = this.allComments.filter((c) => !c.isBlocking);

      // Mostrar estad√≠sticas en la parte superior si hay comentarios
      if (blocking.length === 0 && tracking.length === 0) {
        return Promise.resolve([]);
      }

      // Crear elementos de categor√≠a visual
      const result: CommentInfo[] = [];

      if (blocking.length > 0) {
        // Agregar header visual para comentarios bloqueantes
        result.push({
          file: '',
          line: 0,
          text: `üö´ BLOCKING (${blocking.length}) - Will prevent commits`,
          word: 'HEADER',
          isBlocking: true,
          category: 'blocking',
        } as CommentInfo);
        result.push(...blocking);
      }

      if (tracking.length > 0) {
        // Agregar header visual para comentarios de seguimiento
        result.push({
          file: '',
          line: 0,
          text: `üìù TRACKING (${tracking.length}) - For organization`,
          word: 'HEADER',
          isBlocking: false,
          category: 'tracking',
        } as CommentInfo);
        result.push(...tracking);
      }

      return Promise.resolve(result);
    }
    return Promise.resolve([]);
  }

  private scanWorkspace(): void {
    this.allComments = [];

    if (!vscode.workspace.workspaceFolders) {
      return;
    }

    const config = vscode.workspace.getConfiguration('todoParanoid');
    const blockingWords = config.get<string[]>('blockingWords', ['PARANOID']);
    const trackingWords = config.get<string[]>('trackingWords', [
      'TODO',
      'FIXME',
    ]);
    const fileExtensions = config.get<string[]>('fileExtensions', [
      '.js',
      '.ts',
    ]);

    vscode.workspace.workspaceFolders.forEach((folder) => {
      this.scanDirectory(
        folder.uri.fsPath,
        blockingWords,
        trackingWords,
        fileExtensions
      );
    });
  }

  private scanDirectory(
    dirPath: string,
    blockingWords: string[],
    trackingWords: string[],
    fileExtensions: string[]
  ): void {
    try {
      const files = fs.readdirSync(dirPath);

      files.forEach((file) => {
        const filePath = path.join(dirPath, file);
        const stat = fs.statSync(filePath);

        if (
          stat.isDirectory() &&
          !file.startsWith('.') &&
          file !== 'node_modules'
        ) {
          this.scanDirectory(
            filePath,
            blockingWords,
            trackingWords,
            fileExtensions
          );
        } else if (
          stat.isFile() &&
          fileExtensions.includes(path.extname(file))
        ) {
          this.scanFile(filePath, blockingWords, trackingWords);
        }
      });
    } catch (error) {
      console.error('Error scanning directory:', error);
    }
  }

  private scanFile(
    filePath: string,
    blockingWords: string[],
    trackingWords: string[]
  ): void {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lines = content.split('\n');

      lines.forEach((line, index) => {
        // Buscar palabras bloqueantes
        blockingWords.forEach((word) => {
          const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
          if (commentRegex.test(line)) {
            this.allComments.push({
              file: filePath,
              line: index + 1,
              text: line.trim(),
              word: word,
              isBlocking: true,
              category: 'blocking',
            });
          }
        });

        // Buscar palabras de seguimiento
        trackingWords.forEach((word) => {
          const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
          if (commentRegex.test(line)) {
            this.allComments.push({
              file: filePath,
              line: index + 1,
              text: line.trim(),
              word: word,
              isBlocking: false,
              category: 'tracking',
            });
          }
        });
      });
    } catch (error) {
      console.error('Error reading file:', filePath, error);
    }
  }
}

export function deactivate() {
  // Limpiar timeout si existe
  if (refreshTimeout) {
    clearTimeout(refreshTimeout);
    refreshTimeout = null;
  }

  // Limpiar decoraciones
  if (blockingDecorationType) {
    blockingDecorationType.dispose();
  }
  if (trackingDecorationType) {
    trackingDecorationType.dispose();
  }

  console.log('üõ°Ô∏è Todo Paranoid deactivated');
}
