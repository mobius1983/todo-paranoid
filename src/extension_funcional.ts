import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';

interface CommentInfo {
  file: string;
  line: number;
  text: string;
  word: string;
  isBlocking: boolean; // Nueva propiedad para distinguir tipos
  category: 'blocking' | 'tracking';
}

async function checkFilesForForbiddenComments(
  resources: any[]
): Promise<CommentInfo[]> {
  const results: CommentInfo[] = [];
  const config = vscode.workspace.getConfiguration('codeGuardian');
  const blockingWords = config.get<string[]>('blockingWords', ['Paranoid']);

  for (const resource of resources) {
    const filePath = resource.fsPath || resource;
    if (fs.existsSync(filePath)) {
      const document = await vscode.workspace.openTextDocument(filePath);
      const comments = scanDocument(document);
      // Solo retornar comentarios que BLOQUEAN operaciones
      results.push(...comments.filter((c) => c.isBlocking));
    }
  }

  return results;
}

async function showStagedFilesWarning(repo: any): Promise<void> {
  try {
    const config = vscode.workspace.getConfiguration('codeGuardian');
    if (!config.get('blockGitOperations', true)) return;

    const stagedFiles = repo.state.indexChanges.map(
      (change: any) => change.uri.fsPath
    );
    const blockingComments = await checkFilesForForbiddenComments(stagedFiles);

    if (blockingComments.length > 0) {
      // Solo mostrar advertencia discreta - el bloqueo real ser√° en el commit
      console.log(
        `Code Guardian: ${blockingComments.length} blocking comments in staged files`
      );
    }
  } catch (error) {
    console.error('Error checking staged files:', error);
  }
}

function setupGitHooks(): void {
  const workspaceFolders = vscode.workspace.workspaceFolders;
  if (!workspaceFolders) return;

  workspaceFolders.forEach((folder) => {
    const gitDir = path.join(folder.uri.fsPath, '.git');
    const hooksDir = path.join(gitDir, 'hooks');
    const preCommitHook = path.join(hooksDir, 'pre-commit');

    if (fs.existsSync(gitDir) && !fs.existsSync(preCommitHook)) {
      // Crear pre-commit hook autom√°ticamente
      const hookContent = generatePreCommitHook();

      vscode.window
        .showInformationMessage(
          'Code Guardian can create a Git pre-commit hook to block commits with forbidden comments. Create it?',
          'Yes',
          'No'
        )
        .then((selection) => {
          if (selection === 'Yes') {
            fs.mkdirSync(hooksDir, { recursive: true });
            fs.writeFileSync(preCommitHook, hookContent, { mode: 0o755 });
            vscode.window.showInformationMessage(
              'Git pre-commit hook created successfully!'
            );
          }
        });
    }
  });
}

function generatePreCommitHook(): string {
  const config = vscode.workspace.getConfiguration('codeGuardian');
  const blockingWords = config.get<string[]>('blockingWords', ['Paranoid']);

  return `#!/bin/sh
# Code Guardian pre-commit hook
# Auto-generated by Code Guardian VS Code Extension

# Only BLOCKING words prevent commits (git add is allowed)
BLOCKING_WORDS="${blockingWords.join('|')}"

# Check staged files for BLOCKING comments only
if git diff --cached --name-only | xargs grep -l -E "(//|#).*($BLOCKING_WORDS)" 2>/dev/null; then
    echo ""
    echo "üö´ Code Guardian: Cannot commit! BLOCKING comments found:"
    echo "================================================================"
    git diff --cached --name-only | xargs grep -n -E "(//|#).*($BLOCKING_WORDS)" 2>/dev/null | while read -r line; do
        echo "üìÅ $line"
    done
    echo "================================================================"
    echo ""
    echo "üí° You can save and test locally, but remove these comments before committing!"
    echo "üî• Blocking words: ${blockingWords.join(', ')}"
    echo ""
    echo "‚úÖ Note: TODO, FIXME, BUG comments are allowed and won't block commits."
    echo ""
    exit 1
fi

echo "‚úÖ Code Guardian: No blocking comments found - commit allowed!"
exit 0
`;
}

interface ForbiddenComment {
  file: string;
  line: number;
  text: string;
  word: string;
}

export function activate(context: vscode.ExtensionContext) {
  console.log('üõ°Ô∏è Code Guardian is now active!');

  // Forzar que el contexto est√© disponible
  vscode.commands.executeCommand('setContext', 'codeGuardian.enabled', true);

  const provider = new CodeGuardianProvider();

  // Registrar provider primero
  vscode.window.registerTreeDataProvider('codeGuardianView', provider);

  const treeView = vscode.window.createTreeView('codeGuardianView', {
    treeDataProvider: provider,
    showCollapseAll: true,
  });

  console.log('üõ°Ô∏è Tree view created:', treeView.visible);

  // Comando para escanear workspace
  const scanCommand = vscode.commands.registerCommand(
    'codeGuardian.scanWorkspace',
    () => {
      provider.refresh();
      vscode.window.showInformationMessage('Code Guardian: Workspace scanned!');
    }
  );

  // Comando para refresh (interno) - REMOVIDO
  // const refreshCommand = vscode.commands.registerCommand('codeGuardian.refreshView', () => {
  //     provider.refresh();
  // });

  // Comando para toggle
  const toggleCommand = vscode.commands.registerCommand(
    'codeGuardian.toggleExtension',
    () => {
      const config = vscode.workspace.getConfiguration('codeGuardian');
      const currentState = config.get('enabled', true);
      config.update(
        'enabled',
        !currentState,
        vscode.ConfigurationTarget.Global
      );
      vscode.window.showInformationMessage(
        `Code Guardian ${!currentState ? 'enabled' : 'disabled'}`
      );
      provider.refresh(); // Refresh view after toggle
    }
  );

  // Mostrar advertencia al guardar archivos con comentarios bloqueantes (pero permitir el guardado)
  const saveListener = vscode.workspace.onWillSaveTextDocument((event) => {
    const config = vscode.workspace.getConfiguration('codeGuardian');
    if (!config.get('enabled', true)) {
      return;
    }

    const document = event.document;
    const allComments = scanDocument(document);
    const blockingComments = allComments.filter((c) => c.isBlocking);

    if (blockingComments.length > 0 && config.get('showNotifications', true)) {
      // Solo mostrar advertencia, NO cancelar el guardado
      vscode.window
        .showWarningMessage(
          `‚ö†Ô∏è File saved with ${blockingComments.length} BLOCKING comment(s). Remember: you won't be able to commit this!`,
          'Show Details'
        )
        .then((selection) => {
          if (selection === 'Show Details') {
            provider.refresh();
          }
        });
    }
  });

  // Interceptar comandos de Git usando la API de Git de VS Code
  const gitExtension = vscode.extensions.getExtension('vscode.git')?.exports;
  if (gitExtension) {
    const git = gitExtension.getAPI(1);

    // Interceptar antes de hacer stage (git add)
    git.repositories.forEach((repo: any) => {
      const originalAdd = repo.add;
      repo.add = async function (resources: any) {
        // git add SIEMPRE pasa - no verificamos nada aqu√≠
        return originalAdd.call(this, resources);
      };
    });

    // Interceptar COMMITS (aqu√≠ s√≠ bloqueamos)
    git.repositories.forEach((repo: any) => {
      const originalCommit = repo.commit;
      repo.commit = async function (message: string, opts?: any) {
        const config = vscode.workspace.getConfiguration('codeGuardian');
        if (
          !config.get('enabled', true) ||
          !config.get('blockGitOperations', true)
        ) {
          return originalCommit.call(this, message, opts);
        }

        // Verificar archivos STAGED antes del commit
        const stagedFiles = repo.state.indexChanges.map(
          (change: any) => change.uri.fsPath
        );
        const blockingComments = await checkFilesForForbiddenComments(
          stagedFiles
        );

        if (blockingComments.length > 0) {
          const message = `üö´ Cannot commit! Found BLOCKING comments:\n${blockingComments
            .map(
              (f) => `üìÅ ${path.basename(f.file)} (Line ${f.line}): ${f.word}`
            )
            .join('\n')}\n\nüí° Remove these comments before committing!`;
          vscode.window
            .showErrorMessage(message, 'Show Details')
            .then((selection) => {
              if (selection === 'Show Details') {
                provider.refresh();
                treeView.reveal(blockingComments[0]);
              }
            });
          throw new Error('Blocking comments found - cannot commit');
        }

        return originalCommit.call(this, message, opts);
      };
    });

    // Tambi√©n interceptar commits por terminal usando Git hooks
    git.repositories.forEach((repo: any) => {
      repo.onDidRunGitStatus(() => {
        // Solo mostrar advertencias sobre archivos staged, no bloquear
        showStagedFilesWarning(repo);
      });
    });
  }

  // M√©todo alternativo: Interceptar usando hooks de Git
  setupGitHooks();

  // Escanear en tiempo real mientras escribes
  const changeListener = vscode.workspace.onDidChangeTextDocument((event) => {
    const config = vscode.workspace.getConfiguration('codeGuardian');
    if (!config.get('enabled', true)) return;

    const document = event.document;
    const allComments = scanDocument(document);

    if (allComments.length > 0 && config.get('showNotifications', true)) {
      // Decorar l√≠neas - diferentes colores para diferentes tipos
      highlightComments(document, allComments);
    }
  });

  context.subscriptions.push(
    scanCommand,
    toggleCommand,
    saveListener,
    changeListener,
    treeView
  );

  // Escaneo inicial
  provider.refresh();

  // Log para debug
  console.log('üõ°Ô∏è Code Guardian: All components registered successfully');
}

function scanDocument(document: vscode.TextDocument): CommentInfo[] {
  const config = vscode.workspace.getConfiguration('codeGuardian');
  const blockingWords = config.get<string[]>('blockingWords', ['Paranoid']);
  const trackingWords = config.get<string[]>('trackingWords', [
    'TODO',
    'FIXME',
    'BUG',
  ]);
  const fileExtensions = config.get<string[]>('fileExtensions', ['.js', '.ts']);

  const fileExt = path.extname(document.fileName);
  if (!fileExtensions.includes(fileExt)) {
    return [];
  }

  const results: CommentInfo[] = [];
  const text = document.getText();
  const lines = text.split('\n');

  lines.forEach((line, index) => {
    // Verificar palabras bloqueantes (cr√≠ticas)
    blockingWords.forEach((word) => {
      const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
      if (commentRegex.test(line)) {
        results.push({
          file: document.fileName,
          line: index + 1,
          text: line.trim(),
          word: word,
          isBlocking: true,
          category: 'blocking',
        });
      }
    });

    // Verificar palabras de seguimiento (organizacionales)
    trackingWords.forEach((word) => {
      const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
      if (commentRegex.test(line)) {
        results.push({
          file: document.fileName,
          line: index + 1,
          text: line.trim(),
          word: word,
          isBlocking: false,
          category: 'tracking',
        });
      }
    });
  });

  return results;
}

function highlightComments(
  document: vscode.TextDocument,
  comments: CommentInfo[]
) {
  const editor = vscode.window.activeTextEditor;
  if (!editor || editor.document !== document) return;

  // Decoraci√≥n para comentarios BLOQUEANTES (rojo)
  const blockingDecorationType = vscode.window.createTextEditorDecorationType({
    backgroundColor: 'rgba(255, 0, 0, 0.3)',
    border: '2px solid red',
    borderRadius: '2px',
  });

  // Decoraci√≥n para comentarios de SEGUIMIENTO (amarillo)
  const trackingDecorationType = vscode.window.createTextEditorDecorationType({
    backgroundColor: 'rgba(255, 255, 0, 0.2)',
    border: '1px solid orange',
    borderRadius: '2px',
  });

  const blockingRanges = comments
    .filter((c) => c.isBlocking)
    .map((comment) => {
      const line = document.lineAt(comment.line - 1);
      return new vscode.Range(line.range.start, line.range.end);
    });

  const trackingRanges = comments
    .filter((c) => !c.isBlocking)
    .map((comment) => {
      const line = document.lineAt(comment.line - 1);
      return new vscode.Range(line.range.start, line.range.end);
    });

  editor.setDecorations(blockingDecorationType, blockingRanges);
  editor.setDecorations(trackingDecorationType, trackingRanges);
}

class CodeGuardianProvider implements vscode.TreeDataProvider<CommentInfo> {
  private _onDidChangeTreeData: vscode.EventEmitter<
    CommentInfo | undefined | null | void
  > = new vscode.EventEmitter<CommentInfo | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<
    CommentInfo | undefined | null | void
  > = this._onDidChangeTreeData.event;

  private allComments: CommentInfo[] = [];

  refresh(): void {
    this.scanWorkspace();
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: CommentInfo): vscode.TreeItem {
    // Headers de categor√≠a
    if (element.word === 'HEADER') {
      const item = new vscode.TreeItem(
        element.text,
        vscode.TreeItemCollapsibleState.None
      );
      item.iconPath = element.isBlocking
        ? new vscode.ThemeIcon(
            'error',
            new vscode.ThemeColor('errorForeground')
          )
        : new vscode.ThemeIcon('info', new vscode.ThemeColor('foreground'));
      item.contextValue = 'header';
      return item;
    }

    // Elementos normales de comentarios
    const item = new vscode.TreeItem(
      `${path.basename(element.file)} (Line ${element.line})`,
      vscode.TreeItemCollapsibleState.None
    );

    item.description = element.text;
    item.tooltip = `${element.file}:${element.line}\n${element.text}\nWord: ${element.word}\nType: ${element.category}`;

    // Diferentes iconos seg√∫n el tipo
    if (element.isBlocking) {
      item.iconPath = new vscode.ThemeIcon(
        'circle-filled',
        new vscode.ThemeColor('errorForeground')
      );
      item.contextValue = 'blockingComment';
    } else {
      item.iconPath = new vscode.ThemeIcon(
        'circle-outline',
        new vscode.ThemeColor('warningForeground')
      );
      item.contextValue = 'trackingComment';
    }

    item.command = {
      command: 'vscode.open',
      title: 'Open File',
      arguments: [
        vscode.Uri.file(element.file),
        {
          selection: new vscode.Range(element.line - 1, 0, element.line - 1, 0),
        },
      ],
    };

    return item;
  }

  getChildren(element?: CommentInfo): Thenable<CommentInfo[]> {
    if (!element) {
      // Organizar por categor√≠as y luego por archivos
      const blocking = this.allComments.filter((c) => c.isBlocking);
      const tracking = this.allComments.filter((c) => !c.isBlocking);

      // Mostrar estad√≠sticas en la parte superior si hay comentarios
      if (blocking.length === 0 && tracking.length === 0) {
        return Promise.resolve([]);
      }

      // Crear elementos de categor√≠a visual
      const result: CommentInfo[] = [];

      if (blocking.length > 0) {
        // Agregar header visual para comentarios bloqueantes
        result.push({
          file: '',
          line: 0,
          text: `üö´ BLOCKING (${blocking.length}) - Will prevent commits`,
          word: 'HEADER',
          isBlocking: true,
          category: 'blocking',
        } as CommentInfo);
        result.push(...blocking);
      }

      if (tracking.length > 0) {
        // Agregar header visual para comentarios de seguimiento
        result.push({
          file: '',
          line: 0,
          text: `üìù TRACKING (${tracking.length}) - For organization`,
          word: 'HEADER',
          isBlocking: false,
          category: 'tracking',
        } as CommentInfo);
        result.push(...tracking);
      }

      return Promise.resolve(result);
    }
    return Promise.resolve([]);
  }

  private scanWorkspace(): void {
    this.allComments = [];

    if (!vscode.workspace.workspaceFolders) {
      return;
    }

    const config = vscode.workspace.getConfiguration('codeGuardian');
    const blockingWords = config.get<string[]>('blockingWords', ['Paranoid']);
    const trackingWords = config.get<string[]>('trackingWords', [
      'TODO',
      'FIXME',
    ]);
    const fileExtensions = config.get<string[]>('fileExtensions', [
      '.js',
      '.ts',
    ]);

    vscode.workspace.workspaceFolders.forEach((folder) => {
      this.scanDirectory(
        folder.uri.fsPath,
        blockingWords,
        trackingWords,
        fileExtensions
      );
    });
  }

  private scanDirectory(
    dirPath: string,
    blockingWords: string[],
    trackingWords: string[],
    fileExtensions: string[]
  ): void {
    try {
      const files = fs.readdirSync(dirPath);

      files.forEach((file) => {
        const filePath = path.join(dirPath, file);
        const stat = fs.statSync(filePath);

        if (
          stat.isDirectory() &&
          !file.startsWith('.') &&
          file !== 'node_modules'
        ) {
          this.scanDirectory(
            filePath,
            blockingWords,
            trackingWords,
            fileExtensions
          );
        } else if (
          stat.isFile() &&
          fileExtensions.includes(path.extname(file))
        ) {
          this.scanFile(filePath, blockingWords, trackingWords);
        }
      });
    } catch (error) {
      console.error('Error scanning directory:', error);
    }
  }

  private scanFile(
    filePath: string,
    blockingWords: string[],
    trackingWords: string[]
  ): void {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lines = content.split('\n');

      lines.forEach((line, index) => {
        // Buscar palabras bloqueantes
        blockingWords.forEach((word) => {
          const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
          if (commentRegex.test(line)) {
            this.allComments.push({
              file: filePath,
              line: index + 1,
              text: line.trim(),
              word: word,
              isBlocking: true,
              category: 'blocking',
            });
          }
        });

        // Buscar palabras de seguimiento
        trackingWords.forEach((word) => {
          const commentRegex = new RegExp(`(//|#).*${word}`, 'i');
          if (commentRegex.test(line)) {
            this.allComments.push({
              file: filePath,
              line: index + 1,
              text: line.trim(),
              word: word,
              isBlocking: false,
              category: 'tracking',
            });
          }
        });
      });
    } catch (error) {
      console.error('Error reading file:', filePath, error);
    }
  }
}

export function deactivate() {}
